title: 《垃圾回收的算法与实现》
date: 2017-11-24 22:02:45
tags: [GC]
categories: Reading
---

# TL;DR

[《垃圾回收的算法与实现》](https://book.douban.com/subject/26821357/)一书的读书笔记。

<!-- more -->

# 笔记

## 第1章 学习GC之前

### GC 是什么

GC实际上可以看做管理堆上内存中对象的一个应用程序。

GC主要做清理工作，然而GC的实现会影响新对象的分配。

### 对象的头部以及域

对象分为`头部`和`域`两个部分，`头部`包含对象的基础信息以及GC相关的信息，`域`则是对象使用者可以直接操作的部分。如果对应到 PHP 上(参见`zend_gc.h`)，在生成 ZVAL 时，实际上会申请一个 `zval_gc_info` 大小的空间：

```
typedef struct _zval_gc_info {
	zval z;
	union {
		gc_root_buffer       *buffered;
		struct _zval_gc_info *next;
	} u;
} zval_gc_info;

// ...

/* The following macros override macros from zend_alloc.h */
#undef  ALLOC_ZVAL
#define ALLOC_ZVAL(z) 									\
	do {												\
		(z) = (zval*)emalloc(sizeof(zval_gc_info));		\
		GC_ZVAL_INIT(z);								\
	} while (0)
```

那么对于上述结构来说，头部应该是名为`u`的联合体以及`zval`中关于引用计数的部分，`zval z`则是对象的域。

### GC算法的评价标准

#### 常用的四大标准

+ 吞吐量，即单位时间内GC处理的内存大小
+ 最大暂停时间，即GC会中断程序正常执行的时间
+ 堆的使用效率，即内存的使用方式以及头信息的占用比例
+ 访问的局部性，即是否能更好的利用高速寄存器

## 第2章 GC标记-清除算法

`标记-清除`算法的核心是从根出发，通过 DFS 逐个标记活动的对象，标记完成之后遍历堆，回收不活动的对象。

这一算法可能会有如下的一些问题：

+ 碎片化引起分配操作时延增大
+ 不兼容写时拷贝（标记内容位于堆中，执行标记动作时触发不必要的复制操作）

碎片化带来的问题是找到合适内存空间可能需要较长的线性查找操作时间。

为了能减低清除操作带来的时间花费，会把清理工作推迟到需要分配新空间时进行，但是可能会影响分配的速度。

### 碎片化问题的权衡

碎片化问题，`标记-清除`算法的解决思路是通过对堆中内存分类进行处理，可以是通过划分多个大小的堆的方式，只允许在特定堆上申请空间，或者是 BiBOP(Big Bag Of Pages) 方法，将堆划分为多个块，每个块只能申请特定大小的空间。

### 写时拷贝问题

为了兼容这一个问题，通过独立设定标记位的形式，管理堆内存，只处理不在堆上的标记位。

## 第3章 引用计数法

引用计数法的特点在于内存空间的管理和对象的管理同时进行。

引用计数有：

+ 即刻回收垃圾
+ 缩短了最大暂停时间
+ 不需要大规模的指针操作

这些优点。

但是也有：

+ 计数器操作繁重
+ 降低内存利用率
+ 实现繁琐
+ 无法解决循环引用问题

等缺点，不过上述部分问题都有成熟的应对方案。

### 计数器操作繁重

通过延迟引用计数法解决根引用计数操作频繁的问题。

核心是预留出ZCT(Zero Count Table)，当一个对象引用计数到达0时加入ZCT，之后在ZCT满之后对根可达的对象引用计数增加，之后在清理引用计数为0的对象。

但是这个会带来的问题是ZCT的大小阈值设定问题，过小频繁触发ZCT扫描，过大导致扫描时长过长。

### 降低内存使用率

#### Sticky引用计数法

可以通过Sticky引用计数法，减少用于计数的数据存储空间（研究证明很少有对象有超过32次引用，即在5个bit的存储空间的情况下），之后通过改进后的`标记-清除`算法进行GC操作，无论是否因为计数器溢出，总能进行GC操作。

改进后的`标记-清除`算法主要的区别在于：

+ 先将所有对象引用计数设置为0
+ 从根引用的对象出发，使用堆栈记录子对象，并且每个对象保证只进入堆栈一次的前提下，逐个增加引用计数
+ 清理上述递归过程后引用计数仍然为0对象

上述操作完成之后可以处理循环引用问题，简单思考一下：如果A对象引用B对象，B对象引用A对象，根据引用计数原理，二者虽然没有其他对象引用，但是因为计数都为1，所以无法被回收。通过上述方法首先引用计数置0之后，由于从根开始，发现没有任何可达的路径，那么这两个对象最后的引用计数为0，可以被GC。

溢出导致引用计数变为0不会影响GC的原因在于从根出发，如果一个对象是垃圾，那么必定没有可以到达的路径，也就是无法将引用计数增加，即最终引用计数为0。但是如果只是因为溢出，对象总有路径可达，所以不会引起无法GC的问题。


