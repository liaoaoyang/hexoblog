title: 《垃圾回收的算法与实现》
date: 2017-11-24 22:02:45
tags: [GC]
categories: Reading
---

# TL;DR

[《垃圾回收的算法与实现》](https://book.douban.com/subject/26821357/)一书的读书笔记。

<!-- more -->

# 笔记

## 第1章 学习GC之前

### GC 是什么

GC实际上可以看做管理堆上内存中对象的一个应用程序。

GC主要做清理工作，然而GC的实现会影响新对象的分配。

### 对象的头部以及域

对象分为`头部`和`域`两个部分，`头部`包含对象的基础信息以及GC相关的信息，`域`则是对象使用者可以直接操作的部分。如果对应到 PHP 上(参见`zend_gc.h`)，在生成 ZVAL 时，实际上会申请一个 `zval_gc_info` 大小的空间：

```
typedef struct _zval_gc_info {
	zval z;
	union {
		gc_root_buffer       *buffered;
		struct _zval_gc_info *next;
	} u;
} zval_gc_info;

// ...

/* The following macros override macros from zend_alloc.h */
#undef  ALLOC_ZVAL
#define ALLOC_ZVAL(z) 									\
	do {												\
		(z) = (zval*)emalloc(sizeof(zval_gc_info));		\
		GC_ZVAL_INIT(z);								\
	} while (0)
```

那么对于上述结构来说，头部应该是名为`u`的联合体以及`zval`中关于引用计数的部分，`zval z`则是对象的域。

### GC算法的评价标准

#### 常用的四大标准

+ 吞吐量，即单位时间内GC处理的内存大小
+ 最大暂停时间，即GC会中断程序正常执行的时间
+ 堆的使用效率，即内存的使用方式以及头信息的占用比例
+ 访问的局部性，即是否能更好的利用高速寄存器

## 第2章 GC标记-清除算法

`标记-清除`算法的核心是从根出发，通过 DFS 逐个标记活动的对象，标记完成之后遍历堆，回收不活动的对象。

这一算法可能会有如下的一些问题：

+ 碎片化引起分配操作时延增大
+ 不兼容写时拷贝（标记内容位于堆中，执行标记动作时触发不必要的复制操作）

碎片化带来的问题是找到合适内存空间可能需要较长的线性查找操作时间。

为了能减低清除操作带来的时间花费，会把清理工作推迟到需要分配新空间时进行，但是可能会影响分配的速度。

### 碎片化问题的权衡

碎片化问题，`标记-清除`算法的解决思路是通过对堆中内存分类进行处理，可以是通过划分多个大小的堆的方式，只允许在特定堆上申请空间，或者是 BiBOP(Big Bag Of Pages) 方法，将堆划分为多个块，每个块只能申请特定大小的空间。

### 写时拷贝问题

为了兼容这一个问题，通过独立设定标记位的形式，管理堆内存，只处理不在堆上的标记位。

## 第3章 引用计数法

引用计数法的特点在于内存空间的管理和对象的管理同时进行。

引用计数有：

+ 即刻回收垃圾
+ 缩短了最大暂停时间
+ 不需要大规模的指针操作

这些优点。

但是也有：

+ 计数器操作繁重
+ 降低内存利用率
+ 实现繁琐
+ 无法解决循环引用问题

等缺点，不过上述部分问题都有成熟的应对方案。

### 计数器操作繁重

通过延迟引用计数法解决根引用计数操作频繁的问题。

核心是预留出ZCT(Zero Count Table)，当一个对象引用计数到达0时加入ZCT，之后在ZCT满之后对根可达的对象引用计数增加，之后在清理引用计数为0的对象。


