title: 《事务处理原理》读书笔记
date: 2016-11-30 23:50:31
tags: [Transaction]
categories: Reading
---

> 事务处理(Transaction Processing, TP)

对于真实世界中的交换产生的记账行为，通过网络连接起来计算机进行处理。

> 在线事务(Online Transaction)

在线用户执行程序，操作数据库。

>  ACID

原子性(Atomicity)：事务或全部执行，或不执行，
一致性(Consistency)：事务保持数据库的内部一致性
隔离性(Isolation)：每个事务不影响其他事务
持久性(Durability)：故障发生时事务不丢失

通过ACID测试才能称之为一个事务系统。

> 原子性(Atomicity)

成功称为提交`commit`，事务异常终止则是`abort`。

对于`已提交`的事务发现错误的，需要有事务补偿（compensating transaction）机制，考虑到任何事务都有可能失败，设计良好的TP系统需要对各类事务有补偿机制。但是补偿仍有可能不够完备，可以通过其他策略进行修正。

> 一致性(Consistency)

数据库事务的一致性指的是“内部一致性”，即满足所有逻辑上的约束，不能出现不合理的值。

一致性不仅仅需要事务系统负责，更需要应用程序参与，而且应用程序负主责。

> 隔离性(Isolation)

隔离性的关键是可串行化。即执行事务集和按顺序逐个执行事务结果一致。

加锁机制是大多数数据库系统保持隔离性的一种方法。

> 持久性(Durability)

事务执行完成，并一定存入稳定存储器，才能称作实现了持久性。

持久性的主要实现方式之一即将事务更新的副本追加到日志文件中获得的，事务提交时，系统会确保写入日志已经写入磁盘，之后返回给应用程序事务已被提交。如果是数据库程序，实际入库时机不定。事务系统崩溃之后，会通过日志进行恢复，且必须通过日志进行恢复。

> 两阶段提交(2PC two-phase commit)

解决涉及多个数据库系统的数据不同步的问题。

由事务管理模块控制。执行两阶段提交时，事务管理器发出两轮消息，第一轮通知所有资源将事务结果写入稳定存储中，所有资源均确认已写入后，发出第二轮消息，通知资源管理器实际提交事务。写入的数据量要足以恢复提交前的状态。

> 集合事务（Transaction Bracketing）

个人理解：集合事务是一组标准的编程模式，提供启动(Start)、提交（Commit）与异常终止（Abort）三个事务命令。

> 组合事务的两种解决方法

+ 实现Start时只执行第一个Start操作，实现Commit操作时只执行最后一个Commit操作
+ 实现每一个事务组合实现包装器代码，在包装器中进行Start/Commit操作，事务操作编写为元方法

> 事务标识符

每个事务都应该有个唯一的事务标识符，启动时分配，通过标识符关联全部事务操作。

> 嵌套事务

嵌套事务在大多数商用系统中不被支持，其表示模式如下：

+ 事务中使用Start命令，则这一事务是其所在事务的子事务
+ 不在事务中使用Start，则这一事务成为顶级事务
+ 顶级的Commit和Abort操作可以影响子事务
+ 子事务Abort只通知父事务，父事务酌情处理
+ 子事务之间是隔离的

> 必备的异常处理

事务故障的恢复，系统故障恢复。

> 保存点（Savepoints）

保存点是通过通知资源记录操作完成状态实现回退部分事务的一种机制。保存点只会保存顶级事务带来的影响，当子事务调用保存点记录状态时，子事务存在并发操作的情况下，使用保存点无法回退单一子事务带来的影响。

> 事务处理系统的影响因素

+ 组件是否共享地址空间
+ 地址空间是否有多个线程中的一个线程在执行
+ 是否有硬件、OS或者语言机制保护共享地址空间的程序，免于意外修改内存

> 事务中间件

提供了API以及各类工具，提供与DB和应用程序的交互功能，对开发人员屏蔽事务操作中的操作系统级别的问题，如多线程、通信和安全性。

> 存储过程VS事务服务器/中间件

存储过程可以完成事务服务器的工作，然而为什么事务服务器/中间件仍然有市场？

原因在于：

+ 数据库对于新的通信协议、特性的添加相当缓慢且稳定
+ 事务服务器/中间件对开发者更友好（语言，特性，规避问题）
+ 事务服务器可水平扩展性远优于数据库（通过事务服务器更容易扩容）

> 队列化的事务处理

+ 队列分为请求队列以及应答队列
+ 队列必须写入到非易失性存储之中
+ TP程序从请求队列获取任务，处理后写入应答队列
+ 客户端和服务端需要在会话中提供足够的上下文，用于恢复和按序处理

> 队列化的事务处理对于不可撤销操作的处理

对于输出，如果只是涉及到非实物的情况，那么影响并不大。
但是当涉及金钱出入等问题时，需要处理，方法是在出应答队列之前先写入日志，如果没有前期的写入日志的情况，那么说明并没有执行过这一步骤，如果存在，需要人工告知或者通过其他手段确认到底是否可以执行这一操作。总而言之，即先记录动作，再实际操作（带来的问题可能是对用户的不良体验，但是保证了TP系统不会遭受损失）。

个人理解：比如ATM出钞操作，步骤如下：

1. 由于已经扣款，那么取款机启动一个事务，从应答队列中，取出此次取款操作的返回值，即成功取款；
2. 本地查看是否有本次取款的物理出钞记录，没有则进行到3，有则终止
3. 记录本次出钞
4. 实际打开取钞盒，吐出钞票
5. 提交事务

> 两阶段锁定（two-phase locking）

一个事务必须在释放其获得的锁之前得到他的锁定。

目的在于不留出因为先解锁后加锁带来的可供其他事物修改已锁定目标的时间段。两阶段锁定生效的有效的前提是事务只通过事务内读取和写入两种操作进行交互，如果借助了其他手段，那么会破坏可靠性。

如果一个执行中的事务都遵循两阶段锁定，此执行就是可串行化的。

> 死锁解决的唯一方法

终止死锁涉及到的事务之一。

> 死锁检测的技术

`基于超时`与`基于图形`的检测。

`基于超时`的检测易于实现，但是可能会终止实际上并没有死锁的事务，同样的由于基于时间进行控制，也会让死锁持续过久。

`基于图形`的检测，通过`等待图`(waits-for graph)这一工具进行，从直观上，节点表示事务，边根据方向A->B，表示A上等待着B上的一个锁定被解除，当锁定解除时，边会被删除，当出现闭环时，说明存在死锁。检查可以是定期检测。同时，基于图形的死锁检测同时也可以在边上设定允许的等待时间，超时的循环存在则可以有效的检验死锁。

然而基于超时的检测并非一无是处，在异构拓扑，以及分布式网络环境中，效果较好。

> 死锁牺牲品的选择

+ 产生了循环的事务（最易于发现）
+ 锁数量最少的事务（完成最少工作量）
+ 生成日志最少的事务（成本最低）
+ 写入锁数量最少的事务（成本最低）

> 死锁的循环式重新启动问题（cyclic restart）

被牺牲的事务因为重新启动又触发死锁，导致无法进行。解决办法是可以将启动时间作为牺牲的考虑因素，牺牲最晚出现的事务。

> 死锁触发的因素

+ 锁转换（lock conversion）：多个事务同时要求将同一位置上的读锁转换为写锁，由于两阶段锁定的限制，需要先解锁读锁，但是多个事务互相等待其他事务上读锁的释放，于是死锁；解决方法是对于影响范围先上写锁，确定不需要更改时降级为读锁定，或者使用不和读锁冲突的共享锁模式，先上共享锁，会比先上写锁的方式提高一定并发度。共享锁因为和读锁不冲突，不需要进行解锁等操作，所以不会触发死锁。
+ 锁抖动（lock thrashing）：启动太多事务，由于请求锁的数量倍增，会阻塞住大量事务，造成吞吐量减小的情况。



