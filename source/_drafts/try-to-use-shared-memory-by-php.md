title: PHP 使用共享内存
date: 2017-01-04 00:55:40
tags: [PHP]
---

# 概述

[共享内存](https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98)指在多处理器的计算机系统中，可以被不同中CPU访问的大容量内存。是众多进程间通信（IPC）方式中最快的一种，无需进行数据拷贝等操作，即可在各个进程之间共享数据。

PHP同样也提供了对共享内存操作的可能性，通过`shmop`扩展实现。

# 应用

结合一个实际使用的场景，PHP daemon多进程从上游获取用户ID，需要与指定数据集去重，用户ID大约为12位的数字。要求是不能多去重（即不能存在误伤的判断），但是也不能少去重。

考虑到多进程处理时，需要考虑如何实现便捷，快速的进行判断用户ID已存在于数据集之中。在数据结构上可以使用的几种方法有：

+ Bitmap
+ Hash
+ Array

下面分别说明三者的优缺点：

## Bitmap

Bitmap（位图，以下不加区分的使用）的特点在于数据密度大时（即已排序的情况下，相邻数字间隔不大），是极为节省内存用量的数据结构。无论数字多大，在内存中只通过`1 Bit`进行表示。假设用`1 Byte`的空间进行数字的表示，数据集为[1,3,4,5,7]，则这一组数据的位图可以表示为：

```
01011101
```

即便数字相当巨大，在已知最小值的情况下，同样通过同样大小的空间也可表示，如数据集为[100000001,100000003,100000004,100000005,100000007]，同样也可以用同样一个位图进行表示，因为所有数字的都可以认为相对于`100000000`进行了偏移操作。

Bitmap操作起来速度与便利性也相当令人满意，只需要根据数字大小，找到对应的位，判断当前位的0/1值即可，位运算操作的速度之快无需多言。

然而，Bitmap的最大问题在于，如果存储的是数值的顺序信息，那么整个Bitmap的数据才是最有效的。即，如果已经数字本身是有序的，如从1开始，一直到10000，或者是有办法迅速的知道位置是1的数字的具体字面值，那么存储的位会更加的高效。

在存储用户ID这一个场景时，Bitmap不一定适用，因为用户ID可能会长于10位，如果把用户ID当成数字来看，同时考虑到可能存在的一些业务形态（6，8之类的靓号逻辑，4之类的避讳逻辑），可能得到的Bitmap就相当的“稀疏”（0过多，1过少），造成的结果就是内存的有效使用率降低。假设用户ID最大值是9999999999，仅仅在10位数的用户ID的情况下，为了包含所有的数字，需要开辟约**1192.09MB**大小的内存空间，当然实际应用中很可能会比这个要小，通过找到偏移值（获取比较集的最大最小值，确定偏移值，减少无用0的内存占用）、数据分块（比如前5位相同的比率大，把数字前5位作为一个集合，只生成后5位的Bitmap提高表示有效程度）等方式，但是又会引入一些其他的问题，或者效果不佳（比较集合中存在1和9999999999两个用户ID）或者是难于管理（前5位有上万种组合
）。

如果在可以接受误伤的情况下，有一个更优的方案，即布隆过滤器，这是通过Bitmap可以完成的，综合速度和存储压力都较优方案。


